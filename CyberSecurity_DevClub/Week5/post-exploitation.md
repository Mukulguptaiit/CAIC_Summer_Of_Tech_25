# Post-Exploitation: From Access to Control

Post-exploitation is where the real work begins. You've gained initial access, but now you need to maintain that access, gather intelligence, and achieve your objectives. This guide teaches you to think strategically about what comes after the initial compromise.

---

## The Post-Exploitation Mindset

### Beyond the Initial Victory
Getting a shell is just the beginning. Real cyber operations require:
- **Maintaining Access**: Your initial foothold can be lost easily
- **Expanding Access**: Moving from limited user to administrator privileges
- **Intelligence Gathering**: Understanding the network, users, and valuable data
- **Mission Completion**: Achieving your actual objectives, not just gaining access

### The Persistence Imperative
Your initial access is fragile:
- **User logs out**: Many shells die when the user session ends
- **Service restarts**: Web shells disappear when services are restarted
- **Network issues**: Reverse shells can be interrupted by network problems
- **Admin actions**: System administrators might discover and kill your process

### Thinking Like an APT
Advanced Persistent Threats (APTs) succeed because they think long-term:
- **Multiple access methods**: Never rely on a single way in
- **Gradual escalation**: Avoid noisy activities that trigger alerts
- **Blending in**: Use legitimate tools and normal-looking activities
- **Patience**: Take time to understand the environment before making moves

---

## Intelligence Gathering - Know Your Environment

### Network Topology Discovery
Understanding the network helps you plan lateral movement:

**What You're Looking For**:
- **Network segments**: Different VLANs, DMZs, and internal networks
- **Critical servers**: Domain controllers, database servers, file servers
- **User workstations**: Potential targets for lateral movement
- **Network devices**: Routers, switches that might have weak credentials

**Discovery Techniques**:
```bash
# Network interfaces and routing
ip route                    # Modern Linux routing table
route -n                   # Traditional routing table
ip addr show               # Network interfaces and IP addresses
arp -a                     # ARP cache (recently contacted hosts)
```

**What This Tells You**:
- Multiple network interfaces suggest network segmentation
- Default routes show how to reach other networks
- ARP entries reveal recently active hosts
- IP ranges help you understand network architecture

### Active Directory Reconnaissance
In Windows environments, AD is the crown jewel:

**Why AD Matters**:
- **Centralized authentication**: Controls access to everything
- **Group policies**: Can be abused for persistence and lateral movement
- **Service accounts**: Often have elevated privileges
- **Trust relationships**: Paths to other domains and forests

**Basic AD Enumeration**:
```powershell
# Domain information
echo $env:USERDOMAIN                    # Current domain
nltest /dclist:                         # Domain controllers
net user /domain                        # Domain users
net group "Domain Admins" /domain       # Domain administrators
```

### Service and Application Discovery
Understanding what's running helps identify targets:

**Service Enumeration Logic**:
```bash
# What's listening locally?
netstat -tulpn              # Network services
ss -tulpn                  # Modern alternative

# What processes are running?
ps aux                     # All processes with details
```

**Why This Matters**:
- Database services might contain sensitive information
- Web services could have additional vulnerabilities
- Admin tools might provide escalation opportunities
- Custom applications often have weak security

### User and Privilege Mapping
Understanding who has what access guides your next moves:

**User Discovery Strategy**:
```bash
# Who's on this system?
who                        # Currently logged in
w                          # Detailed current sessions
last                       # Login history

# What groups exist?
cat /etc/group             # All groups and members
groups username            # Specific user's groups
```

**What Groups Tell You**:
- `sudo`, `wheel`: Administrative access
- `docker`: Potential container escape
- `adm`: Log file access
- Custom groups: Application-specific privileges

*See [intelligence_gathering.py](code_examples/intelligence_gathering.py) for automated enumeration scripts*

---

## Establishing Persistence - Maintaining Your Foothold

### Understanding Persistence Requirements
Good persistence mechanisms are:
- **Reliable**: Survive reboots and service restarts
- **Stealthy**: Avoid detection by administrators and security tools
- **Redundant**: Multiple methods ensure you don't lose access
- **Appropriate**: Match the sophistication to your needs and risk tolerance

### Linux Persistence Techniques

**SSH Key-Based Persistence**:
This is often the most reliable method on Linux systems:

**Why SSH Keys Work Well**:
- Legitimate authentication method (doesn't look suspicious)
- Survives reboots and service restarts
- Works from anywhere on the network
- Often overlooked in incident response

*See [ssh_persistence.py](code_examples/ssh_persistence.py) for automated SSH key management*

**Systemd Service Persistence**:
Modern Linux systems use systemd for service management:

**Why Systemd Services Are Powerful**:
- Start automatically on boot
- Restart if they crash
- Can run as any user (including root)
- Integrate with legitimate system management

*See [systemd_persistence.py](code_examples/systemd_persistence.py) for service creation automation*

**Cron-Based Persistence**:
Scheduled tasks provide reliable execution:

**Cron Advantages**:
- Predictable execution times
- Can be user-specific or system-wide
- Easy to make look legitimate
- Multiple locations for redundancy

*See [cron_persistence.py](code_examples/cron_persistence.py) for automated cron job creation*

### Windows Persistence Techniques

**Registry Run Keys**:
Classic Windows persistence through registry:

**Why Registry Persistence Works**:
- Executes on user login
- Multiple registry locations available
- Can target specific users or all users
- Part of normal Windows startup process

**Service-Based Persistence**:
Windows services provide powerful persistence with system-level privileges.

**WMI Event Subscription**:
Advanced Windows persistence using WMI:

**Why WMI Persistence Is Powerful**:
- Difficult to detect
- Can trigger on various system events
- Operates at a low level in Windows
- Often overlooked by administrators

*See [windows_persistence.py](code_examples/windows_persistence.py) for Windows persistence automation*

---

## Lateral Movement - Expanding Your Reach

### Understanding Lateral Movement
Lateral movement is the process of moving from your initial compromise to other systems in the network:

**Why Lateral Movement Matters**:
- **Access critical systems**: Your initial target might not have the data you need
- **Privilege escalation**: Other systems might have weaker security
- **Redundancy**: Multiple compromised systems provide backup access
- **Mission completion**: Achieve objectives that require access to specific systems

### Network Authentication Mechanisms

**Understanding How Authentication Works**:
- **Local accounts**: Stored only on the specific machine
- **Domain accounts**: Centrally managed, work across multiple systems
- **Service accounts**: Used by applications and services
- **Cached credentials**: Stored locally for offline authentication

### Pass-the-Hash Attacks
One of the most effective lateral movement techniques:

**How Pass-the-Hash Works**:
1. You compromise a system and extract password hashes
2. Instead of cracking the password, you use the hash directly
3. Many Windows protocols accept the hash as authentication
4. You gain access to other systems without knowing the actual password

**Why This Attack Is So Effective**:
- Windows stores NTLM hashes in memory
- Many users have local admin rights on multiple machines
- Service accounts often have broad network access
- Hashes don't change unless passwords are reset

*See [credential_harvesting.py](code_examples/credential_harvesting.py) for credential extraction automation*

### Credential Hunting Strategies

**Where Credentials Hide**:
- **Memory**: Current login sessions store credentials
- **Configuration files**: Applications often store database passwords
- **Scripts**: Automation scripts frequently contain hardcoded credentials
- **Browser storage**: Saved passwords and authentication tokens
- **Network shares**: Shared folders often contain configuration files

### SSH Key Reuse
SSH keys are often reused across multiple systems:

**Why SSH Key Reuse Is Common**:
- Administrators create one key pair and copy it everywhere
- Automation scripts use the same keys for multiple targets
- Users don't understand the security implications
- It's convenient and seems secure

*See [lateral_movement.py](code_examples/lateral_movement.py) for automated lateral movement techniques*

---

## Data Exfiltration - Getting Information Out

### Understanding Data Value
Not all data is equally valuable:

**High-Value Targets**:
- **Customer databases**: Personal information, payment data
- **Intellectual property**: Source code, designs, business plans
- **Credentials**: Passwords, API keys, certificates
- **Financial information**: Accounting data, budgets, forecasts
- **Communications**: Emails, chat logs, documents

### Exfiltration Constraints
Real-world data exfiltration faces many challenges:

**Network Monitoring**:
- **DLP systems**: Monitor for sensitive data patterns
- **Traffic analysis**: Unusual upload volumes trigger alerts
- **Protocol restrictions**: Only certain protocols might be allowed outbound

**Data Size Considerations**:
- **Large datasets**: Difficult to transfer without detection
- **Bandwidth limitations**: Slow connections make large transfers impractical
- **Time constraints**: Limited window before discovery

### Covert Channel Techniques

**DNS Exfiltration**:
Using DNS queries to smuggle data out:

**Why DNS Works Well**:
- DNS traffic is rarely blocked
- Queries look legitimate to most monitoring
- Can work even in restricted networks
- Many tools don't deeply inspect DNS content

**ICMP Tunneling**:
Using ping packets to carry data:

**ICMP Advantages**:
- Often allowed through firewalls
- Doesn't require open ports
- Looks like network troubleshooting
- Can carry arbitrary data in packet payload

**HTTP/HTTPS Exfiltration**:
Hiding data in legitimate-looking web traffic using steganographic approaches.

*See [data_exfiltration.py](code_examples/data_exfiltration.py) for covert channel implementations*

---

## Anti-Forensics - Covering Your Tracks

### Understanding Digital Forensics
Forensic investigators look for:
- **File system artifacts**: Created, modified, accessed timestamps
- **Log entries**: System and application logs showing your activities
- **Network evidence**: Connection logs, packet captures
- **Memory artifacts**: Process execution evidence in RAM dumps
- **Registry changes**: Windows registry modifications

### Log Management Strategies

**Understanding Linux Logs**:
- **auth.log**: Authentication attempts and sudo usage
- **syslog**: General system messages
- **access.log**: Web server access records
- **command history**: User command execution records

**Selective Log Editing**:
Instead of deleting entire logs (which is suspicious), edit specific entries to remove traces of your activities.

### Timestamp Manipulation
File timestamps tell a story to forensic investigators:

**Why Timestamps Matter**:
- Show when files were created, modified, accessed
- Help investigators build timelines
- Reveal the sequence of attacker activities
- Can link related files together

### Process and Memory Cleanup
Running processes leave evidence in memory and system monitoring.

*See [anti_forensics.py](code_examples/anti_forensics.py) for log cleaning and timestamp manipulation tools*

---

## Covert Communication Channels

### The Need for Stealth
Direct reverse shells are easily detected:
- **Network monitoring**: Unusual outbound connections trigger alerts
- **Behavior analysis**: Constant connections to external IPs look suspicious
- **Port scanning**: Security teams monitor for unexpected listening ports

### Domain Fronting
Using legitimate services to hide your real destination:

**How Domain Fronting Works**:
1. Use a legitimate CDN or cloud service (like CloudFlare)
2. Make HTTPS requests to the legitimate domain
3. Use the Host header to specify your real destination
4. The CDN forwards your traffic to your actual server
5. Monitoring only sees connections to the legitimate service

### Protocol Tunneling
Hiding your traffic inside legitimate protocols:

**SSH Tunneling**:
If SSH is allowed outbound, you can tunnel other protocols through encrypted SSH connections.

**HTTP/HTTPS Tunneling**:
Making non-HTTP traffic look like web browsing by encoding commands in HTTP headers and POST data.

### Dead Drop Communication
Asynchronous communication using shared resources:

**Why Dead Drops Work**:
- No direct connection between attacker and victim
- Uses legitimate services (harder to block)
- Harder to trace back to the attacker
- Can work around network isolation

**Dead Drop Implementations**:
- **Social media**: Post commands as comments, read responses
- **Cloud storage**: Upload/download files with commands and results
- **DNS**: Use DNS TXT records for bidirectional communication
- **Email**: Automated email processing for command and control

*See [covert_channels.py](code_examples/covert_channels.py) for stealth communication implementations*

---

## Building Your Post-Exploitation Toolkit

### Essential Concepts to Master
- **Persistence fundamentals**: Understanding what makes persistence reliable and stealthy
- **Network reconnaissance**: Mapping networks and identifying high-value targets
- **Credential handling**: Safely extracting, storing, and reusing credentials
- **Traffic analysis**: Understanding what network activity looks suspicious

### Advanced Techniques for Study
- **Living off the land**: Using legitimate system tools for malicious purposes
- **Memory manipulation**: Advanced credential extraction from system memory
- **Container escape**: Breaking out of Docker and other containerized environments
- **Cloud pivot**: Moving between cloud services and accounts

### Professional Development
- **Red team methodologies**: Learn industry-standard attack frameworks
- **Blue team perspective**: Understand how defenders detect post-exploitation activities
- **Compliance awareness**: Know the legal and ethical boundaries of your testing
- **Documentation skills**: Properly record and report your findings

### Practice Environments
- **Active Directory labs**: Practice domain-based lateral movement
- **Cloud environments**: Learn AWS, Azure, and GCP post-exploitation
- **Container platforms**: Kubernetes and Docker escape techniques
- **Network simulation**: Tools like GNS3 for complex network scenarios

---

## Code Examples Overview

All practical implementations are in separate files in the `code_examples/` directory:

- **intelligence_gathering.py**: Network and system enumeration automation
- **ssh_persistence.py**: SSH key-based persistence management
- **systemd_persistence.py**: Linux service persistence creation
- **cron_persistence.py**: Scheduled task persistence automation
- **windows_persistence.py**: Windows-specific persistence techniques
- **credential_harvesting.py**: Memory and file-based credential extraction
- **lateral_movement.py**: Network movement and authentication abuse
- **data_exfiltration.py**: Covert data extraction channels
- **anti_forensics.py**: Log cleaning and evidence removal
- **covert_channels.py**: Stealth communication implementations

Each file includes detailed comments explaining the techniques, when to use them, and how defenders might detect them. Understanding both sides of the equation makes you more effective as either an attacker or defender.